# Software requirements

The requirements aim to clearly translate what is to be built 
from the user's perspective.
These requirements are meant for designers, developers and testers.

Requirements aim to be:

- *Cohesive* units, about one thing ☝
- *Fully described*, in one place 📦
- *Consistent*, avoiding contradictions and ambiguity with each other 🚅
- *Atomic*, as in validate A and B becomes validate A and validate B 🔬
- *Traceable*, as all requirements are in and well labeled with IDs 🔖
- *Current* and maintained, to avoid obsolete items and 
  confusion with farfetched features ✨
- *Unambiguous*, with minimal jargon and extra details, factual and subject 
  to one interpretation 🔑
- *With specified importance* based on user value, stakeholder value, 
  time or budget (shall, should, could, ) 🏆
- *Verifiable* or testable, as checkmark-able once built 🔨

The requirements have been divided into:

1. [Context](./01-01-req-context.md)
1. [Business requirements](./01-02-req-business.md)
1. [User requirements](./01-03-req-user.md)
1. [Functional requirements](./01-04-req-functional.md)
1. [Non-functional requirements](./01-05-req-non-functional.md)
1. [Interface requirements](./01-06-req-interface.md)

While the sections may not encompass all the content described
in the context description at first, 
the requirements will grow with the project.

The writing style for the following requirements varies between:

- *traditional text*,
- *user stories*, and
- *use cases*.

Happy reading! 🙂
